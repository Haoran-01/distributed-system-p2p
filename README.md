# Design Document

## 1. design

### 1.1 图

<img src=".\photos\流程图.drawio-1668444962275-1.svg" alt="流程图.drawio" style="zoom:50%;" /> <img src="D:\OneDrive\OneDrive - University College Dublin\大学\大三上\DS\photos\P2P.drawio.svg" alt="P2P.drawio" style="zoom:50%;" />





![流程图.drawio](E:\UCD-OneDrive\OneDrive - University College Dublin\大学\大三上\DS\photos\流程图.drawio.svg)

我的p2p 聊天程序主要分为两个部分，一个部分是服务器另一个部分为客户端。不同于p2s，p2p中的服务器只负责维持和客户端的连接以及进行广播消息。我的程序中使用了`ServerScoket ` 和 `socket` 使客户端和服务器建立了TCP连接。服务器中存有所有当前连接的客户端的信息，当有新的客户端连接或者有客户端断开连接时，服务器会更新在线用户列表并广播给所有在线用户。客户端如果想与其他客户端发送信息，需要获取服务器的最新广播内的在线用户列表，从列表中找到对应的客户端接口建立连接并发送信息。

### 1.2 解释设计思路

#### 1.2.1 GUI

使用了JAVA Swing来进行UI界面设计。

**客户端界面**

<img src="E:\UCD-OneDrive\OneDrive - University College Dublin\大学\大三上\DS\photos\image-20221114162337430.png" alt="image-20221114162337430" style="zoom: 50%;" />

用户可以选择服务器的IP地址，服务器端口来连接不同的服务器。同时要有独一无二的用户名字以及唯一的端口号，当用户连接到服务器后，只有按下Adminstrator radio button才可以使用Kick this ID的功能，目前非管理员的用户不可以使用KICK_ID的功能。Available Chat Name 可以实时同步当前服务器连接客户端的姓名与端口号，当其他客户端连接服务器或者断开与服务器连接时，这个区域将会刷新。ID Stats按钮是用来查询选择的ID的权限（即能使用的控制命令），所有该ID能使用的ID会展现在下方Recieved Messages里。

Broadcast按钮是为向所有连接到服务器的客户端广播message，Send Message按钮则要求输入想要发送信息的对象，该对象必须是在Available Chat Name中的。会把message发送给该指定用户。下面的Status展示了当前的状态，会展示当前客户端状态以及错误类型。Recieved Message会展示所有的广播信息以及其他客户端发送过来的信息。

**服务器端界面**

<img src="E:\UCD-OneDrive\OneDrive - University College Dublin\大学\大三上\DS\photos\image-20221114135109365.png" alt="image-20221114135109365" style="zoom:50%;" />

服务器端可以选择服务器的端口，启动服务器后，Current connected users会根据用户端的连接与端口进行实时更新，显示目前连接到服务器的客户端的信息。下方的区域是用来显示服务器收到的消息。

#### 1.2.2 数据类

- `Message` class 用于客户端与服务器的信息交流
- `SendMessage` class 用与客户端与客户端的信息交流
- `ChatUserInfo` class 用于存储客户端的具体信息
- `UserList` class 用于存储 `ChatUserInfo` 对象 

#### 1.2.3 Server class

服务器端分为一个主线程和多个子线程，服务器的主线程一直处于等待状态，负责接受新的客户端的连接。当有新的客户端通过服务器接口连接到服务器上，服务器会创建一个新的`ChatUserInfo` 对象储存客户端的详细信息，包括用户姓名，IP地址，端口号，是否为管理员等信息。并且将这个对象储存到主线程内一个`UserList`对象内。接着服务器会打开一个子线程来发送和监听这个客户端的信息，并将为该用户分配的端口号也存入 `ChatUserInfo` 对象内，方便后续对不同线程的控制。主线程内有一个`Vecotr<Scoket> sockets` 来储存服务器的所有套接字，方便对各个子线程进行管理。主线程负责管理各个子线程，进行广播，当有新的客户端连接到服务器时，服务器会对所有已连接的客户端进行广播，并发送当前的客户端列表。方便客户端进行客户端与客户端之间信息发送。

服务器子线程负责接受来自客户端的信息和发送信息给客户端，当连接存在时持续对相应客户端进行监听，处理客户端发来的信息，解析后进行对应的操作，当收到客户端发送的带有kick请求的信息，会搜索发送过来的用户id并进行kick操作，断开与该id对应线程的套接字。当客户端断开与服务器连接时，也会对所有已连接的客户端进行广播告知该客户端断开连接，并且更新客户端列表，并将更新后的客户端列表广播给所有在线用户。

#### 1.2.4 client

客户端也分为一个主线程和多个子线程，主线程一直处于等待状态，用于接受服务器端的消息，如获取所有当前在线用户列表以及得到其他用户上线通知以及广播信息。同时主线程启动时也会启动另外一个监听线程，用于监听控制台的输入，并且根据输入内容执行相应的命令。

客户端子线程是用来监听其他客户端发送的信息，为了实现p2p，客户端可以与其他客户端直接进行交流，当客户端连接服务器时，会创建一个`ServerScoket` 用于监听其他客户端发送的信息。此时客户端可以看作一个服务器端。子线程会进入等待状态，当其他客户端发送过来信息时，接收完信息会断开与其他客户端的连接。客户端当想要和其他客户端发送信息时，会先向服务器发送请求，获得当前的在线用户列表，通过搜索用户名得到想要连接的客户端的端口号，发送信息至该端口。

#### 1.2.5 ConsoleListener

使用`ConsoleListener` 类来进行监听控制台的操作。`ConsoleListener` 类内有一个 `HashMap<String,Action> answer` 来储存特定的命令以及这个命令启动的动作，键值为控制台输入的命令，值为特定的 `Action`。`ConsoleListener` 类会创建一个新的线程用于持续监控控制台的输入，用 `Scanner` 来读取控制台输入，并在 `answer` 内搜索是否命令列表内包含控制台输入的内容，如果输入内容不包含在 `answer` 会调用默认的 `Action` 即通知错误的命令格式，如果输入内容包含在 `answer` 内，会调用命令所对应的 `Action` 操作。所有 `	Action` 的操作在创建客户主线程的时候会自动创建，并通过 `addAction` 函数存储到`ConsoleListener` 的`HashMap<String,Action>` 内。当在控制台输入符合规定的命令时，会调用相应`Action` 的 `act（line）` 函数，执行所对应的操作。这些`Action.act` 的操作会处理控制台输入的内容，提取其中的`{content}` 以及 `ID` 来进行特定的操作。当客户端关闭时，会关闭这个客户端的控制台监听线程。

所有的指令为

- `BROADCAST_{content}` 广播 `content` 到所有用户端
  - 通过调用client class 中的`broadcastData()`函数实现，提取`content`作为发送给服务器消息的内容，通过服务器对所有在线客户端进行广播 

- `MESSAGE_ID_{content}` 发送 `content` 到 `ID` 所对应的客户端
  - 通过调用client class 中的`sendData()`实现，提取`ID`和`content`，根据`ID`搜索到对应的端口号，向其发送信息。

- `STOP` 断开当前客户端与服务器的链接
  - 通过调用GUI界面disconneted的点击函数断开客户端与服务器的连接。

- `LIST` 展示所有目前与服务器连接的客户端的用户ID
  - 展示出最近一次服务器广播消息中的当前用户列表

- `KICK_ID ` 断开 `ID` 所对应的客户端与服务器的连接
  - 这个命令只有当前客户为管理员时才可以使用，会向服务器发送一个带有kick标识和想要踢出用户ID的信息，服务器会读取ID并断开该ID所对应端口的套接字。断开该用户与服务器的连接.

- `STATS_ID` 展示该 `ID` 所对应客户端的所有可用指令
  - 提取出ID后通过搜索服务器发送过来的用户列表信息，找到对应的`ChatUserInfo`对象，通过判断该用户是否是管理员，展示出不同的可用指令。


## 3. pros and cons

优点：

- 容错性高， 任何一个客户端的崩溃都不会影响整个系统
- [去中心化](https://so.csdn.net/so/search?q=去中心化&spm=1001.2101.3001.7020)在P2P网络中，不存在客户端与服务器这样的严格区分，同时每个节点又充当着客户端和服务器。各个节点之间是平等的，只要接入网络，任意节点都能够将消息通知给网络中的每个节点。

缺点：

- 客户端与服务器端发送的message对象过于复杂，包含内容多
- 目前这个系统只能在本地局域网内使用
